<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 前言</a></li><li><a href="chapters/01-INTRO.html"><strong>2.</strong> 第一章 无线通信系统简介</a></li><li><a href="chapters/02-SDR.html"><strong>3.</strong> 第二章 SDR简介</a></li><li><a href="chapters/03-PHY.html"><strong>4.</strong> 第三章 OFDM物理层</a></li><li><a href="chapters/04-LLC.html"><strong>5.</strong> 第四章 数据链路层</a></li><li><a href="chapters/05-APP.html"><strong>6.</strong> 第五章 传输层与应用层</a></li><li><a href="labs/lab0_pluto.html"><strong>7.</strong> Lab0 配置Pluto环境</a></li><li><a href="labs/lab1_sync.html"><strong>8.</strong> Lab1 帧同步实验</a></li><li><a href="labs/lab2_phy.html"><strong>9.</strong> Lab2 物理层实验</a></li><li><a href="labs/lab3_llc.html"><strong>10.</strong> Lab3 链路层实验</a></li><li><a href="labs/project.html"><strong>11.</strong> Project 大作业</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#前言" id="前言"><h1>前言</h1></a>
<p>本书为厦门大学信息与通信工程系的《专业方向性实践（二）》课程编写。该课程是为高年级通信专业本科生开设，目前是大三下必选课。旨在通过指导同学们在软件无线电平台上完成一个实时无线通信系统（包括物理层、链路层与应用层），提升同学们对通信系统的理解，同时也提升同学们的动手实践能力。</p>
<p>本书计划分两部分，第一部分是理论，第二部分是相关的实验。目前只完成了第二部分。第一部分未完成，拟采用Wyglinski, A.M., Getz, R., Collins, T. and Pu, D., 2018. Software-defined radio for engineers. Artech House的中译本（材料将在课程群内发布）。</p>
<p>本课程内容主要参考北邮刘弈彤教授的《软件无线电实验》课程、Princeton大学Kyle Jamieson教授的《COS463: Wireless Networks》课程、UIUC大学Haitham Hassanieh教授的《ECE463: IoT and Software Defined Radio Lab》课程。结合厦大实际情况，确定了如下的课程内容与方式：</p>
<p>（1）基于ADI Pluto的软件无线电与Python编程语言设计课程内容。学生们在大三上的《通信原理》课程上已熟悉ADI Pluto软件无线电平台，学生们在大三上《专业方向性实践（一）》课程上已熟悉Python编程语言。虽然Python语言在信号处理效率上没有C语言甚至FPGA高，但是上手容易，而我们的系统实现实时性要求不高；与Matlab比起来，Python更容易搭建实时系统。</p>
<p>（2）基于OFDM技术组织课程内容。与传统的数字调制方式（ASK/PSK/FSK）比起来，OFDM会更复杂。但是考虑到OFDM技术已被主流的通信系统（包括无线与水声）所采纳，是前沿技术，具有很强的生命力。此外，如何处理通信系统的实际因素，比如多径信道、Time
Offset、Carrier Frequency Offset，都能通过OFDM系统很好的展示出来。因此本课程以WiFi 802.11a系统为例，通过讲解OFDM的原理与实现细节，贯穿通信基本知识（比如信道、调制、编码）。</p>
<p>（3）采取通信与网络相结合的方式。传统的通信类实践课程往往关注物理层设计，较少涉及MAC层、链路层、网络层、传输层，不能全面体现一个完整的通信系统。基于软件无线电平台提供的全栈开发能力，本课程引入MAC协议、链路层可靠传输协议（自动请求重传协议）、虚拟网卡（TUN/TAP）的技术开发框架，使学生能够对通信系统有全面的理解。</p>
<p>（4）采用阶梯式开发方式。本课程设计了三个实验，一个大项目，贯穿整个学期。各个环节相互依赖，比如第二个实验依赖第一个实验的结果，第三个实验依赖前两个实验搭建的系统，大项目依赖前三个实验的结果，将难度分解到平时的各个环节，确保学生能够在期末实现一个完整的实时通信系统。</p>
<a class="header" href="print.html#第一章-无线通信系统简介" id="第一章-无线通信系统简介"><h1>第一章 无线通信系统简介</h1></a>
<a class="header" href="print.html#第二章-sdr简介" id="第二章-sdr简介"><h1>第二章 SDR简介</h1></a>
<a class="header" href="print.html#21-模拟信号与数字信号" id="21-模拟信号与数字信号"><h2>2.1 模拟信号与数字信号</h2></a>
<a class="header" href="print.html#22-基带信号的iq表示" id="22-基带信号的iq表示"><h2>2.2 基带信号的I/Q表示</h2></a>
<a class="header" href="print.html#23-软件无线电" id="23-软件无线电"><h2>2.3 软件无线电</h2></a>
<a class="header" href="print.html#231-软件无线电简介" id="231-软件无线电简介"><h3>2.3.1 软件无线电简介</h3></a>
<a class="header" href="print.html#232-sdr通用架构" id="232-sdr通用架构"><h3>2.3.2 SDR通用架构</h3></a>
<a class="header" href="print.html#233-adi-pluto-sdr平台简介" id="233-adi-pluto-sdr平台简介"><h3>2.3.3 ADI Pluto SDR平台简介</h3></a>
<a class="header" href="print.html#第四章-ofdm物理层" id="第四章-ofdm物理层"><h1>第四章 OFDM物理层</h1></a>
<a class="header" href="print.html#第五章-数据链路层" id="第五章-数据链路层"><h1>第五章 数据链路层</h1></a>
<a class="header" href="print.html#第六章-传输层与应用层" id="第六章-传输层与应用层"><h1>第六章 传输层与应用层</h1></a>
<a class="header" href="print.html#lab0-plutosdr环境配置" id="lab0-plutosdr环境配置"><h1>Lab0 PlutoSDR环境配置</h1></a>
<p>作者：</p>
<ul>
<li>游理钊：lizhaoyou@xmu.edu.cn</li>
<li>汤智榕：ttangzr@163.com</li>
</ul>
<p>时间：</p>
<ul>
<li>初稿：2022年1月30日</li>
<li>修正：2022年12月30日</li>
</ul>
<a class="header" href="print.html#简介" id="简介"><h3>简介</h3></a>
<p>ADI Pluto是一种低成本的软件无线电设备，非常适合教学。Pluto可以在Windows系统下运行，也可以在Linux系统下运行，只需要安装好相应的驱动。本课程将采用Python语言进行编程，推荐使用Python 3.7。Python编程的IDE可以使用Pycharm。</p>
<a class="header" href="print.html#windows-10" id="windows-10"><h3>Windows 10</h3></a>
<p>1、下载并安装PlutoSDR-M2k-USB-Drivers-v0.8</p>
<pre><code class="language-bash">https://github.com/analogdevicesinc/plutosdr-m2k-drivers-win/releases/download/v0.8/PlutoSDR-M2k-USB-Drivers.exe
</code></pre>
<p>2、下载并安装libiio-0.23.gc14a0f8-Windows-setup</p>
<pre><code class="language-bash">https://github.com/analogdevicesinc/libiio/releases/download/v0.23/libiio-0.23.gc14a0f8-Windows-setup.exe
</code></pre>
<p>3、下载并安装miniconda (主要用于管理Python环境，也可用conda)</p>
<pre><code class="language-bash">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.9.2-Windows-x86_64.exe
</code></pre>
<p>4、安装必要python packages</p>
<pre><code class="language-bash">$ conda activate base
$ pip install pylibiio==0.23.1
$ pip install pyadi-iio==0.0.12
$ pip install scipy==1.7.3 numpy==1.21.4
</code></pre>
<p>5、插入Pluto硬件，并进行测试</p>
<pre><code class="language-bash">$ conda activate base
$ python3
&gt;&gt;&gt; import adi
&gt;&gt;&gt; sdr = adi.Pluto('ip:192.168.2.1') # or whatever your Pluto's IP is
&gt;&gt;&gt; sdr.sample_rate = int(2.5e6)
&gt;&gt;&gt; sdr.rx()
</code></pre>
<a class="header" href="print.html#linux-ubuntu-16041804" id="linux-ubuntu-16041804"><h3>Linux (Ubuntu 16.04/18.04)</h3></a>
<p>推荐使用裸系统，使用虚拟机会降低性能</p>
<p>1、下载并安装miniconda (用于管理Python环境，也可用conda)</p>
<pre><code class="language-bash">$ sudo mkdir -p /opt
$ sudo chmod -R 777 /opt
$ wget &quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.9.2-Linux-x86_64.sh&quot; -O /opt/miniconda3.sh --no-check-certificate
$ bash /opt/miniconda3.sh
$ conda activate base
</code></pre>
<p>2、安装package依赖</p>
<pre><code class="language-bash">$ sudo apt-get update
$ sudo apt-get install git libxml2 libxml2-dev bison flex libcdk5-dev cmake libusb-1.0-0 libusb-1.0-0-dev libavahi-common-dev libavahi-client-dev libaio-dev -y
</code></pre>
<p>3、安装libiio</p>
<pre><code class="language-bash">$ cd /opt/
$ git clone --branch v0.23 https://gitee.com/ttangzr/libiio.git libiio
$ cd libiio
$ cmake ./
$ make all -j4
$ sudo make install
$ sudo ldconfig
$ cd bindings/python/
$ sudo python setup.py.cmakein install
</code></pre>
<p>4、安装libad9361-iio</p>
<pre><code class="language-bash">$ cd /opt/
$ git clone --branch v0.2 https://gitee.com/ttangzr/libad9361-iio.git libad9361-iio
$ cd libad9361-iio
$ cmake ./
$ make -j4
$ sudo make install
</code></pre>
<p>5、安装pyadi-iio等packages</p>
<pre><code class="language-bash">$ pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyadi-iio==0.0.11 scipy==1.7.3 numpy==1.21.4
</code></pre>
<p>6、插入Pluto硬件，并进行测试</p>
<pre><code class="language-bash">$ conda activate base
$ python3
&gt;&gt;&gt; import adi
&gt;&gt;&gt; sdr = adi.Pluto('ip:192.168.2.1') # or whatever your Pluto's IP is
&gt;&gt;&gt; sdr.sample_rate = int(2.5e6)
&gt;&gt;&gt; sdr.rx()
</code></pre>
<a class="header" href="print.html#lab1-帧同步实验" id="lab1-帧同步实验"><h1>Lab1 帧同步实验</h1></a>
<a class="header" href="print.html#注意事项" id="注意事项"><h2>注意事项</h2></a>
<blockquote>
<ul>
<li>截止日期：2023年4月3日23:59</li>
<li>提交邮箱：ruicao@stu.xmu.edu.cn</li>
<li><strong>逾期提交每天会扣除5%的分数，最高扣35%</strong></li>
</ul>
</blockquote>
<a class="header" href="print.html#简介-1" id="简介-1"><h2>简介</h2></a>
<p>在本实验，我们将实现基本的帧同步（frame synchronization）模块，并将通过Pluto设备进行发送和接收。通过实现该模块，对帧同步有一定的了解，同时也掌握如何使用Pluto硬件。</p>
<p>对于任何的MAC协议，参与无线通信的设备都需要进行帧同步，以发现正在传输的帧。实际传输过程中，会让发送机节点发送已知信号（preambles，通常称为“前导码”），而接收机节点将监听该信号。具体来说，前导码是在数据开始时发送前的波形，用于指示数据的开始。前导码波形是预先定义好的，因此不携带任何数据。接收机将侦听前导码，当检测到前导码后，接收机将开始解调数据包的其余部分。</p>
<p>首先，我们使用已经采集好的信号实现帧同步，采用课上提到的多种方式。然后，我们使用Pluto进行发送和接收，发送已知的信号，并对记录的信号执行帧同步。最后，我们将在Pluto上实现一个实时帧同步模块。</p>
<a class="header" href="print.html#第一部分实现帧同步检测函数60" id="第一部分实现帧同步检测函数60"><h2>第一部分：实现帧同步检测函数（60%）</h2></a>
<p>在这部分中，我们将探讨如何检测并同步到前导码。</p>
<p>检测和同步都可以使用相关操作来完成。两个离散信号x和y的相关结果是另一个离散信号，其定义为</p>
<p>$$
(x*y)[k] = \sum_{n=-∞}^{∞}x^\dagger[n] \cdot y[n+k]
$$</p>
<p>换句话说，在每个索引k处，取第一个信号x的共轭，将第二个信号y偏移k个索引，然后将得到的两个信号相加。直观地说，相关性是衡量一个信号相对于另一个信号的相似度。在本课程中，我们会提到两种相关方法：自相关（auto-correlation）和互相关（cross-correlation）。虽然它们都使用相关的方法，但在他们的计算复杂度会有所不同。</p>
<p>此外，我们还提到了另外两种方法：能量检测和双滑动窗口检测。你需要实现这些方法。</p>
<a class="header" href="print.html#问题11使用互相关进行前导码检测20" id="问题11使用互相关进行前导码检测20"><h3>问题1.1：使用互相关进行前导码检测（20%）</h3></a>
<p>实现基于互相关的前导码检测器：</p>
<ul>
<li>完善下面的detect_preamble_cross_correlation函数，通过下面的测试代码。该函数应接收两个信号，预先定义的preamble，需要做相关的信号signal。若找到前导码，则返回前导码开始位置的索引，若未找到，则返回None。</li>
<li>提交代码</li>
</ul>
<pre><code class="language-python"># import settings  
import math  
import numpy as np  
from matplotlib import pyplot
</code></pre>
<pre><code class="language-python"># Compare the correlation magnitude against this value to determine whether there is a preamble or not  
def detect_preamble_cross_correlation(preamble, signal):  
    pass
</code></pre>
<pre><code class="language-python"># This cell will test your implementation of `detect_preamble`  
preamble_length = 100  
signal_length = 1000  
preamble = (np.random.random(preamble_length) + 1j * np.random.random(preamble_length))
signalA = np.random.random(signal_length) + 1j * np.random.random(signal_length)  
signalB = np.random.random(signal_length) + 1j * np.random.random(signal_length)  
preamble_start_idx = 123  
signalB[preamble_start_idx:preamble_start_idx + preamble_length] += preamble  
  
np.testing.assert_equal(detect_preamble_cross_correlation(preamble, signalA), None)
np.testing.assert_equal(detect_preamble_cross_correlation(preamble, signalB), preamble_start_idx)
</code></pre>
<a class="header" href="print.html#问题12使用自相关进行前导码检测20" id="问题12使用自相关进行前导码检测20"><h3>问题1.2：使用自相关进行前导码检测（20%）</h3></a>
<p>实现基于自相关的前导码检测器（公式在课程中的ppt中已定义，可以使用迭代或递归公式来计算c[n]）：</p>
<ul>
<li>完善下面detect_preamble_auto_correlation函数，通过下面的测试代码。该函数应接收两个信号，需要做自相关的信号signal，信号中重复信号的长度short_preamble_len。若找到前导码，则返回前导码开始位置的索引，若未找到，则返回None。</li>
<li>提交代码</li>
</ul>
<pre><code class="language-python">def detect_preamble_auto_correlation(signal, short_preamble_len):  
    pass
</code></pre>
<pre><code class="language-python"># This cell will test your implementation of `detect_preamble`  
short_preamble_length = 20  
signal_length = 1000  
short_preamble = np.exp(2j * np.pi * np.random.random(short_preamble_length))  
preamble = np.tile(short_preamble, 10)  # 重复十次
noise = np.random.normal(size=signal_length) + 1j * np.random.normal(size=signal_length)  
signalA = 0.1 * noise  
signalB = 0.1 * noise  
preamble_start_idx = 321  
signalB[preamble_start_idx:preamble_start_idx + len(preamble)] += preamble  
np.testing.assert_equal(detect_preamble_auto_correlation(preamble, signalA), None)  
np.testing.assert_equal(detect_preamble_auto_correlation(preamble, signalB) in range(preamble_start_idx-5, preamble_start_idx+5), True)
</code></pre>
<a class="header" href="print.html#问题13使用能量检测进行前导码检测10" id="问题13使用能量检测进行前导码检测10"><h3>问题1.3：使用能量检测进行前导码检测（10%）</h3></a>
<p>实现基于能量检测的前导码检测器：</p>
<ul>
<li>完善下面的detect_preamble_by_energy函数</li>
<li>提交代码</li>
</ul>
<pre><code class="language-python">def detect_preamble_by_energy(signal):  
    pass
</code></pre>
<a class="header" href="print.html#问题14使用双滑动窗口的前导码检测10" id="问题14使用双滑动窗口的前导码检测10"><h3>问题1.4：使用双滑动窗口的前导码检测（10%）</h3></a>
<p>实现基于双滑动窗口的前导码检测器：</p>
<ul>
<li>完善下面的detect_preamble_sliding函数</li>
<li>提交代码</li>
</ul>
<pre><code class="language-python">def detect_preamble_by_sliding_window(signal, short_preamble_len):  
    pass
</code></pre>
<a class="header" href="print.html#第二部分使用预先采集的信号进行帧同步20" id="第二部分使用预先采集的信号进行帧同步20"><h2>第二部分：使用预先采集的信号进行帧同步（20%）</h2></a>
<p>有两个已事先记录好的信号：一个强信号和一个弱信号。每个信号文件中均有多个数据包。请增强上述函数以找出数据包开头的索引列表。</p>
<p>帧结构：|——10STS——|—2.5LTS—|———20 OFDM data symbols———|</p>
<p>每个帧的前导码由10个短训练序列（Short Training Symbol，STS）和2.5个长训练序列（Long Training Symbol，LTS）组成。1个STS长度为16，第一部分一共160 samples；1个LTS长度为64，第二部分一共160 samples，包括32+64+64。</p>
<p>尝试使用preamble_lts或preamble_sts执行上述四种帧同步方法。</p>
<p>要求（提交报告）</p>
<ul>
<li>使用能量检测方法执行同步：绘制能量图，计算SNR，并输出所有数据包起始索引。</li>
<li>使用双滑动窗口方法执行同步：绘制滑动计算结果图，并输出所有数据包开始索引。</li>
<li>使用互相关方法执行同步：绘制互相关结果，并输出所有数据包开头的索引。</li>
<li>使用自相关方法执行同步：绘制自相关结果，并输出所有数据包开头的索引。</li>
<li>请根据给定的弱信号和强信号的实验结果，对报告中的四种方法进行分析与总结。</li>
</ul>
<pre><code class="language-python">preamble_lts = np.load(&quot;preamble_lts.npy&quot;)  
preamble_sts = np.load(&quot;preamble_sts.npy&quot;)  
received_signal_weak = np.load(&quot;recorded_signal_weak.npy&quot;)  
received_signal_strong = np.load(&quot;recorded_signal_strong.npy&quot;)
</code></pre>
<a class="header" href="print.html#第三部分使用pluto采集的信号进行帧同步20" id="第三部分使用pluto采集的信号进行帧同步20"><h2>第三部分：使用Pluto采集的信号进行帧同步（20%）</h2></a>
<a class="header" href="print.html#问题31尝试使用pluto设备记录信号10" id="问题31尝试使用pluto设备记录信号10"><h3>问题3.1：尝试使用Pluto设备记录信号（10%）</h3></a>
<p>你可以使用以下程序记录信号。你需要将两个Pluto连接到你的电脑（或者分别连接到一台电脑上），使用下列IP: 192.168.2.1和IP: 192.168.3.2（或程序中的其他IP）。</p>
<p>注意：</p>
<ul>
<li>需要实现设置好Pluto硬件的IP参数</li>
<li>你可以调整发射机中的tx_gain参数（或调整收发机的距离），以获得不同SNR的记录信号。</li>
</ul>
<pre><code class="language-python"># Transmitter parameters configuration  
from pluto_interface import pluto_transmitter
&quot;&quot;&quot; Parameters for PlutoSDR device &quot;&quot;&quot;  
tx_args = &quot;ip:192.168.2.1&quot;  
tx_freq = 915e6  
bandwidth = 1e6  
tx_gain = -60  
sdr_tx = pluto_transmitter(tx_args, tx_freq, bandwidth, tx_gain, verbose=True).pluto  
# Get transmitted signal and transmit  
transmitted_signal = np.load(&quot;tx_signal.npy&quot;)  
transmitted_signal = transmitted_signal * (2 ** 14)  
sdr_tx.tx_cyclic_buffer = True  
sdr_tx.tx(transmitted_signal) # Cyclic transmit the signal  
</code></pre>
<pre><code class="language-python"># Receiver parameters configuration  
from pluto_interface import pluto_receiver
&quot;&quot;&quot; Parameters for PlutoSDR device &quot;&quot;&quot;  
rx_args = &quot;ip:192.168.3.2&quot;  
rx_freq = 915e6  
bandwidth = 1e6  
rx_gain = 0  
rx_buffer_size = 1e4  
gain_control_mode = &quot;fast_attack&quot;  
sdr_rx = pluto_receiver(rx_args, rx_freq, bandwidth, rx_gain, rx_buffer_size, gain_control_mode, verbose=True).pluto  
# Receive the signal and record  
received_signal = sdr_rx.rx() # Record a buffer size signal one time  
np.save(&quot;recorded_signal.npy&quot;, received_signal)
</code></pre>
<a class="header" href="print.html#问题32使用记录的信号重复第二部分实验-10" id="问题32使用记录的信号重复第二部分实验-10"><h3>问题3.2：使用记录的信号重复第二部分实验 (10%)</h3></a>
<p>要求</p>
<ul>
<li>截图：显示已正确记录信号的命令行输出</li>
<li>报告：与问题2.1相同</li>
</ul>
<a class="header" href="print.html#第四部分在线信号的帧同步可选加分5" id="第四部分在线信号的帧同步可选加分5"><h2>第四部分：在线信号的帧同步（可选，加分：5%）</h2></a>
<p>你需要快速处理在线信号，并打印数据包的起始索引。你可以再次使用第三部分中的发送机（但需要修改某些部分以显示你发送了多少数据包）。但你需要开发一个实时接收机，能够连续处理输入信号块。</p>
<p>要求</p>
<ul>
<li>报告：如何设计与实现帧同步模块，截图显示实时发送和接收的数据包的数量。</li>
<li>提交代码</li>
</ul>
<a class="header" href="print.html#lab2-物理层实验" id="lab2-物理层实验"><h1>Lab2 物理层实验</h1></a>
<a class="header" href="print.html#注意事项-1" id="注意事项-1"><h2>注意事项</h2></a>
<blockquote>
<ul>
<li>截止日期：2023年5月1日23:59</li>
<li>提交邮箱：ruicao@stu.xmu.edu.cn</li>
<li><strong>逾期提交每天会扣除5%的分数，最高扣35%</strong></li>
</ul>
</blockquote>
<a class="header" href="print.html#简介-2" id="简介-2"><h2>简介</h2></a>
<p>本实验中，我们将开发一个OFDM接收机。在任何通信系统中，接收机通常比发射机更复杂，因为接收机需要处理一些不同形式的信号失真。对于我们的窄带OFDM系统，显然也是如此。</p>
<p>首先，接收方不知道传输将在何时发生，因此存在时间模糊性。我们在实验1中看到了如何用前导码同步来解决这个问题。此外，发射机和接收机具有不同的本地振荡器。振荡器频率不可避免的误差将导致发射机和接收机之间的载波频率偏移（CFO），并且由于振荡器不同步，发射机和接收机之间将有相位偏移。我们需要用前导码估计出CFO并补偿相位。如果我们传输一个长包或高阶调制信号，则需要在数据符号中使用导频来跟踪残留相位偏移。结合用前导码估计出的初始信道，我们能够进行信道均衡，然后解调信号。这样才能完成一个完整的OFDM接收机。</p>
<p>在本实验，首先会给你一些预先采集好的OFDM信号。你的工作是帧同步、估计CFO、消除CFO引起的相位偏移、估计信道，然后解调接收到的信号。然后，你需要自己捕获一个信号，并重复前面的步骤。</p>
<a class="header" href="print.html#基础" id="基础"><h2>基础</h2></a>
<p>帧结构 (时域)</p>
<p>|---------10 STS---------|-----2.5 LTS----|------------ DATA symbols------------|</p>
<p>每个帧的前导码由10个短训练序列（Short Training Symbol，STS）和2.5个长训练序列（Long Training Symbol，LTS）组成。1个STS长度为16，第一部分一共160 samples；1个LTS长度为64，第二部分一共160 samples，包括32+64+64。</p>
<p>每个数据符号的子载波结构 (频域，一般采用正负频率来表示)</p>
<p><img src="https://raw.githubusercontent.com/HZhuyu/images/main/images/frame%20format.png" alt="img" /></p>
<p>本实验会采用64点的FFT。对于FFT后的信号数据序列，可以认为对应的频率位置为[0, ..., f, -f, ..., -1]。此时可以通过fftshift循环移位数据，使得数据对应的频率位置为[-f, ..., 0, ...,  f]。因此我们以上图的[-32:31]的子载波序号来进行具体数据排列描述。</p>
<p>根据上图，为了防止带外干扰，[-32:-27]与[27:31]的子载波填0不传输数据，0号子载波因为存在DC的干扰，一般也不传输数据；[-21 -7 7 21]四个子载波用于放置导频（pilot）；剩下的子载波会用于传输数据，传输数据在子载波上的排列顺序为：[1:6 8:20 22:26 -26:-22 -20:-8 -6:-1]。一共48个数据子载波，4个导频子载波，12个空闲子载波。</p>
<p>一个OFDM发射机的例子在<strong>ofdm_tx.py</strong>给出。接收机可以仿照该例子用python写出。为了降低项目复杂度，本实验还会给一个matlab接收机的例子。</p>
<p>每个OFDM符号的解调都可以看作是调制的逆过程。一种典型的解调步骤如下：</p>
<ol>
<li>使用同步来找到数据包的起始位置。</li>
<li>做CFO估计与补偿。</li>
<li>对每个OFDM符号执行FFT。</li>
<li>从每个包的前导码中提取信道状态信息。</li>
<li>对每个符号进行解调</li>
</ol>
<p>其中第5步有不同的实现方式。后续的实验会让你尝试不同的实现。按照课程上的描述，既考虑residual CFO也考虑SFO的实现步骤如下：</p>
<ul>
<li>5.1 纠正信道（信道均衡）</li>
<li>5.2 估计残留CFO和SFO</li>
<li>5.3 估计每个子载波的累积相位</li>
<li>5.4 补偿每个子载波的累积相位</li>
<li>5.5 解调数据子载波</li>
</ul>
<p>注意：matlab接收机例子是一种简单的实现，忽略了步骤5.2-5.4。在只有AWGN噪声的仿真信号中是可行的，但是面对SDR采集下来的真实信号，可能会存在问题。</p>
<a class="header" href="print.html#第一部分ofdm信号解调-40" id="第一部分ofdm信号解调-40"><h2>第一部分：OFDM信号解调 (40%)</h2></a>
<a class="header" href="print.html#问题11已知数据发送信号的解调-10" id="问题11已知数据发送信号的解调-10"><h3>问题1.1：已知数据发送信号的解调 (10%)</h3></a>
<p>首先使用实验1的TX基带信号进行解调 (发送基带文件：<strong>tx_signal.npy</strong>，原始数据比特文件：<strong>raw_data.npy</strong>用于调试)。这种信号不经过无线信道也没有任何失真。你可以简单地实现调制过程的逆过程来解调。</p>
<p>在这个过程中，你无需执行步骤1、步骤2、步骤5.2~5.4。</p>
<p><strong>要求</strong>：</p>
<ul>
<li>报告：命令行输出显示正确解调</li>
<li>代码：提交开发的接收机程序（python）</li>
</ul>
<a class="header" href="print.html#问题12已知数据接收信号的解调-10" id="问题12已知数据接收信号的解调-10"><h3>问题1.2：已知数据接收信号的解调 (10%)</h3></a>
<p>使用实验1的RX基带信号<strong>recorded_signal_strong.npy</strong>进行解调。一个文件中的所有数据包都是相同的。你可以提取一个包来进行解调。原始数据比特都在文件<strong>raw_data.npy</strong>中，同样提供给你方便调试。</p>
<p>在这个过程中，你需要实现上述完整的步骤。</p>
<p><strong>要求</strong>：</p>
<ul>
<li>报告：命令行输出显示正确解调</li>
<li>代码：提交开发的接收机程序（python）</li>
</ul>
<a class="header" href="print.html#问题13未知数据接收信号的解调-20" id="问题13未知数据接收信号的解调-20"><h3>问题1.3：未知数据接收信号的解调 (20%)</h3></a>
<p>解调给定的采集下来的 BPSK 信号 (即<strong>recorded_signal_10sym.npy</strong>与<strong>recorded_signal_100sym.npy</strong>)并提交解调后的比特。不同的信号有不同的符号长度，<strong>recorded_signal_10sym.npy</strong>有10个数据符号，<strong>recorded_signal_100sym.npy</strong> 有100个数据符号。</p>
<p><strong>要求:</strong></p>
<ul>
<li>数据：提交解调数据 (用 <strong>npy</strong> 格式)</li>
<li>代码：提交开发的接收机程序（python）</li>
</ul>
<a class="header" href="print.html#第二部分ofdm信号解调方法分析-50" id="第二部分ofdm信号解调方法分析-50"><h2>第二部分：OFDM信号解调方法分析 (50%)</h2></a>
<a class="header" href="print.html#问题21解调过程分析-20" id="问题21解调过程分析-20"><h3>问题2.1：解调过程分析 (20%)</h3></a>
<p>按照上述解调方法1，使用 <strong>recorded_signal_100sym.npy</strong> 绘制以下图形。</p>
<p><strong>要求：</strong></p>
<ul>
<li>绘制用长训练序列（LTS）提取的信道幅度。采用X轴为 [-N/2, N/2-1]正负频率的表示形式（下同）。解释你所观察到的信道（例如, 你是否观察到频率选择性衰落）。
<blockquote>
<p>提示：可以使用 <strong>np.fft.fftshift</strong> 将FFT结果从索引 [0, N-1] 移到 [-N/2, N/2-1]。</p>
</blockquote>
</li>
<li>选择一个导频子载波，并绘制一个数据包内所有OFDM符号的相位变化。解释你所观察到的结果。</li>
<li>选择第1个/第10个/第20个OFDM符号, 并在所选符号中使用导频绘制所有子载波相位的线性插值图。解释你所观察到的结果。</li>
<li>绘制信道均衡后所有OFDM子载波的星座点(即步骤5.4执行之后)
<blockquote>
<p>提示: 可以使用 <strong>plt.scatter</strong> 来绘制星座点。</p>
</blockquote>
</li>
</ul>
<a class="header" href="print.html#问题22不做sto引起的相位补偿的分析5" id="问题22不做sto引起的相位补偿的分析5"><h3>问题2.2：不做STO引起的相位补偿的分析（5%）</h3></a>
<p>使用 <strong>recorded_signal_100sym.npy</strong> 绘制以下图形。</p>
<p><strong>要求：</strong></p>
<ul>
<li>如果我们仅在步骤5.2中估计残留CFO，绘制信道均衡后所有OFDM子载波的星座点 (即,不需要进行线性回归，只需将所有导频相位的平均值作为符号中的累积相位即可)。解释你所观察到的现象。</li>
</ul>
<a class="header" href="print.html#问题23不做相位补偿的分析-10" id="问题23不做相位补偿的分析-10"><h3>问题2.3：不做相位补偿的分析 (10%)</h3></a>
<p><strong>要求</strong>:</p>
<ul>
<li>如果跳过步骤5.2-5.4,为<strong>recorded_signal_10sym.npy</strong>绘制信道均衡后所有OFDM子载波的星座点图。将结果与你执行了步骤5.2-5.4的星座图进行比较，并解释你观察到的结果。</li>
<li>如果跳过步骤5.2-5.4, 为<strong>recorded_signal_100sym.npy</strong>绘制信道均衡后所有OFDM子载波的星座点图。将结果与你执行了步骤5.2-5.4的星座图进行比较，并解释你观察到的结果。</li>
<li>回答问题: 如果你不执行相位跟踪，对我们的OFDM系统有什么影响？</li>
</ul>
<a class="header" href="print.html#问题24不做cfo补偿与相位补偿的分析-10" id="问题24不做cfo补偿与相位补偿的分析-10"><h3>问题2.4：不做CFO补偿与相位补偿的分析 (10%)</h3></a>
<p><strong>要求</strong>:</p>
<ul>
<li>如果跳过步骤2和5.2-5.4, 为
<strong>recorded_signal_10sym.npy</strong>绘制信道均衡后所有OFDM子载波的星座点图。将结果与问题2.3和3.1中的星座点进行比较，并解释你所观察到的结果。</li>
<li>如果跳过步骤2和5.2-5.4, 为
<strong>recorded_signal_100sym.npy</strong>绘制信道均衡后所有OFDM子载波的星座点图。将结果与问题2.3和3.1中的星座点进行比较，并解释你所观察到的结果。</li>
</ul>
<a class="header" href="print.html#问题25研究cp去除位置的影响-5" id="问题25研究cp去除位置的影响-5"><h3>问题2.5：研究CP去除位置的影响 (5%)</h3></a>
<p>CP去除的位置（以及FFT解调窗口位置）可能会影响解调结果。你可以选择两个位置去除CP，比较估计的信道和解调结果。</p>
<p><strong>要求:</strong></p>
<ul>
<li>对于<strong>recorded_signal_10sym.npy</strong>，选择两个位置去除CP，放上屏幕截图显示使用两种CP去除位置均可以解调成功。</li>
<li>比较两种CP去除位置下的信道估计结果，画出两个信道的振幅和相位，画出两个信道的相位差，并解释你所观察到的结果。</li>
</ul>
<a class="header" href="print.html#第三部分采集一个信号并对其进行解调-10" id="第三部分采集一个信号并对其进行解调-10"><h2>第三部分：采集一个信号并对其进行解调 (10%)</h2></a>
<p>你需要使用示例发射机发送一个包，并使用Pluto采集基带信号并解调它。选取一个比较高SNR的信号，可以通过调整发射机的功率（即设置 <strong>tx_gain</strong>）或调整距离以产生高SNR。</p>
<p>发送机可以采用如下代码进行参数配置，注意OfdmTx是在<strong>ofdm_tx.py</strong>实现：</p>
<pre><code class="language-python">from ofdm.pluto_interface import pluto_transmitter
from ofdm.ofdm_tx import OfdmTx

# Transmitter parameters configuration  
&quot;&quot;&quot; Parameters for PlutoSDR device &quot;&quot;&quot;
tx_args = &quot;ip:192.168.2.1&quot;  
tx_freq = 915e6  
bandwidth = 1e6  
tx_gain = -20  
sdr_tx = pluto_transmitter(tx_args, tx_freq, bandwidth, tx_gain, verbose=True).pluto  
# Receiver parameters configuration  

# Parameters for OFDM PHY  
n = 64  # Number of bits within every OFDM symbol  
cp = 16  # length of cyclic prefix within every OFDM symbol  
qam_size = 2  
pilot_pattern = 'custom'  
preamble_type = '802.11'  
num_symbol = 100  
ofdm_transmitter = OfdmTx(tx_args, tx_freq, bandwidth, tx_gain, n, cp, qam_size, pilot_pattern, preamble_type, num_symbol, verbose=True)  
</code></pre>
<p>以下是从随机包连续传输生成的基带信号并采集信号的示例代码。</p>
<pre><code class="language-python"># Receive the signal and record  
received_signal = sdr_rx.rx() # Record a buffer size signal one time  
np.save(&quot;recorded_signal.npy&quot;, received_signal) 

# Transmit the signal  
raw_data = np.random.randint(low=0, high=2, size=4800)  
OFDM_packet = ofdm_transmitter.process(raw_data) # Generate transmitted signal  
transmitted_signal = OFDM_packet * (2 ** 14)  
sdr_tx.tx_cyclic_buffer = True  
sdr_tx.tx(transmitted_signal) # Cyclic transmit the signal  
</code></pre>
<p>如果你要周期性的发送数据包，你需要将 tx_cyclic_buffer 设置为false, 并使用 for 循环发送数据包（可能需要一些休眠时间来减慢传输速率）。</p>
<pre><code class="language-python">sdr_tx.tx_cyclic_buffer = False
for packet_num in range(0, 1000):
  sdr_tx.tx(transmitted_signal)
  # time.sleep(0.01)
  print(&quot;Tx num:&quot;, packet_num)
</code></pre>
<p>接收机可以采用如下代码进行参数配置：</p>
<pre><code class="language-python">from ofdm.pluto_interface import pluto_receiver

&quot;&quot;&quot; Parameters for PlutoSDR device &quot;&quot;&quot;  
rx_args = &quot;ip:192.168.3.2&quot;  
rx_freq = 915e6  
bandwidth = 1e6  
rx_gain = 0  
rx_buffer_size = 1e5  
gain_control_mode = &quot;fast_attack&quot;  
sdr_rx = pluto_receiver(rx_args, rx_freq, bandwidth, rx_gain, rx_buffer_size, gain_control_mode, verbose=True).pluto  

# Receive the signal and record
received_signal = sdr_rx.rx()  # Record a buffer size signal one time
np.save(&quot;received_signal.npy&quot;, received_signal)
</code></pre>
<p><strong>要求</strong>:</p>
<ul>
<li>数据包长度是 4800 比特，对应多少个OFDM符号，是否与调制方式有关？raw_data大小和OFDM_packet大小有什么关系？</li>
<li>截图：屏幕截图显示你的解调数据与发送的raw_data相匹配。</li>
<li>给出信号的SNR值，绘制OFDM解调星座点。</li>
</ul>
<a class="header" href="print.html#第四部分发送qpsk调制信号并解调-可选加分5" id="第四部分发送qpsk调制信号并解调-可选加分5"><h2>第四部分：发送QPSK调制信号并解调 (可选，加分：5%)</h2></a>
<p>在相同的数据符号长度下，高阶调制可以传输更多的数据位，但对解调误差更敏感。 在这个问题中，你尝试解调QPSK信号。BPSK 信号和 QPSK 信号之间的唯一区别是在子载波调制/解调步骤上（即步骤 5.5）。你需要传输一个包含100个数据符号的长数据包（即9600 比特）。</p>
<p><strong>要求:</strong></p>
<ul>
<li>绘制OFDM解调星座点。</li>
<li>将解调后的数据与raw_data进行对比来检查你是否解调正确。放上已成功解调QPSK的屏幕截图。</li>
</ul>
<p><strong>提示:</strong></p>
<ul>
<li>可以改变发送机程序中的<strong>qam_size = 4</strong> 和 <strong>size = 9600</strong> 来产生 QPSK信号。</li>
<li>请注意，如果采用上述发送机，QPSK是使用<strong>格雷码</strong>来调制每个子载波中的两个比特，接收机需要遵循同样的映射规则才能正确解调。</li>
</ul>
<a class="header" href="print.html#第五部分实现实时在线解调-可选无加分大项目要求" id="第五部分实现实时在线解调-可选无加分大项目要求"><h2>第五部分：实现实时在线解调 (可选，无加分，大项目要求)</h2></a>
<p>你需要实现一个至少有20个数据符号的在线解调器。</p>
<p><strong>要求:</strong></p>
<ul>
<li>在实验1的帧同步实时接收机基础上继续开发解调实时接收机。</li>
<li>截图显示你已经传输了多少个数据包，传输的比特，你已经解调了多少数据包以及解调的比特。</li>
</ul>
<a class="header" href="print.html#lab3-链路层实验" id="lab3-链路层实验"><h1>Lab3 链路层实验</h1></a>
<a class="header" href="print.html#注意事项-2" id="注意事项-2"><h3>注意事项</h3></a>
<blockquote>
<ul>
<li>截止日期：2023年5月22日23:59</li>
<li>提交邮箱：hongzhuyu@stu.xmu.edu.cn</li>
<li><strong>逾期提交每天会扣除5%的分数，最高扣35%</strong></li>
</ul>
</blockquote>
<a class="header" href="print.html#简介-3" id="简介-3"><h3>简介</h3></a>
<p>到目前为止，我们已经设计了帧同步和离线OFDM接收机。在本次任务中，我们将首先设计一个“ <strong>在线</strong> OFDM <strong>发射机</strong> 与 <strong>接收机</strong> ”，将所有功能集合在一起，并构建两个单向通信的节点（节点A作为发射机，节点B作为接收机）。</p>
<p>然后，我们将开发一个“在线OFDM收发机”，它可以同时发送和接收数据包。以这种方式，节点A（和节点B）同时充当发射机和接收机。双向通信模型在实践中更为常见，因为“发射机”需要从“接收机”接收反馈。</p>
<p>在线实现并不容易，尤其是对于接收部分。如果无法足够快地处理（来自Pluto设备）传入样本，则会丢弃一些样本。你需要</p>
<ul>
<li>使用CPU的<strong>多核</strong>功能进行并行处理 (创建 <a href="https://www.jianshu.com/p/102db2cc0479">multiple threads</a>);</li>
<li>优化你的设计，使处理时间尽可能短；</li>
<li>如果处理速度赶不上传输速度，请放慢传输速度。(可以通过<strong>sleep</strong>更多时间来控制传输速率);</li>
</ul>
<p>为了帮助设计在线收发机，我们提供</p>
<ul>
<li>一个多线程结构的参考实现，参考代码具有链路层（即LLC）和物理层（即PHY）。此外，该体系结构还创建了几个支持多线程的队列。你只需要在框架内完成一些功能，并让框架充分利用CPU的多个内核。</li>
<li>一个带有 <code>socket</code>的参考物理层. <a href="https://www.cnblogs.com/zaizai1573/p/10217447.html">Socket</a> 是计算机网络课程中引入的一个重要概念，是互联网应用程序的基石。这里，我们使用socket来模拟PHY层，并帮助你理解所提供的参考实现。</li>
</ul>
<a class="header" href="print.html#第一部分-使用socket-phy测试单向通信15" id="第一部分-使用socket-phy测试单向通信15"><h3>第一部分: 使用Socket PHY测试单向通信（15%）</h3></a>
<a class="header" href="print.html#要求" id="要求"><h4>要求</h4></a>
<ul>
<li>运行下面的代码，并记录控制台的输出。(5%)</li>
</ul>
<pre><code class="language-bash">(py37)$ python test_nodeB.py -p socket -l single    # run first
(py37)$ python test_nodeA.py -p socket -l single
</code></pre>
<ul>
<li>问题1: 解释 <code>tx_queue</code>和 <code>rx_packet_queue</code>的功能 (5%)</li>
<li>问题2: 解释 <code>tx_packet_queue_watcher_thread</code>和 <code>rx_packet_queue_watcher_thread</code>. (5%)</li>
</ul>
<a class="header" href="print.html#第二部分-利用ofdm-phy设计单向通信70" id="第二部分-利用ofdm-phy设计单向通信70"><h3>第二部分: 利用OFDM PHY设计单向通信（70%）</h3></a>
<a class="header" href="print.html#21-设计单向ofdm-发射机25" id="21-设计单向ofdm-发射机25"><h4>2.1 设计单向OFDM 发射机（25%）</h4></a>
<a class="header" href="print.html#设置和要求" id="设置和要求"><h4>设置和要求</h4></a>
<ul>
<li>调制LLC层的数据包，并将样本放入 <code>tx_queue</code>，然后完成OfdmTx类的 <code>put()</code> 和 <code>process()</code>。提交你设计的程序。(10%)</li>
<li>添加线程 <code>tx_sample_queue_watcher_thread</code>以从 <code>tx_queue</code>中获取样本，并使用PlutoSDR进行传输。提交你设计的程序。(10%)</li>
<li>问题1：描述单向OFDM发射机的过程。解释控制台输出，并描述它们的作用。<code>socket</code>发射机和 <code>pluto</code>发射机之间的区别是什么？(5%)</li>
</ul>
<a class="header" href="print.html#提示" id="提示"><h4>提示</h4></a>
<ul>
<li>你可以使用Lab2中发射机的源代码来开发OfdmTx类中的 <code>process()</code>函数</li>
<li><code>tx_sample_queue_watcher_thread</code>的设计类似于 <code>tx_packet_queue_watcher_thread</code>.</li>
<li>要使用pluto传输样本，可以调用 <code>sdr_tx.tx(samples)</code>.</li>
</ul>
<a class="header" href="print.html#22-设计单向ofdm接收机45" id="22-设计单向ofdm接收机45"><h4>2.2 设计单向OFDM接收机（45%）</h4></a>
<a class="header" href="print.html#设置和要求-1" id="设置和要求-1"><h5>设置和要求</h5></a>
<ul>
<li>添加线程 <code>rx_sample_queue_watcher_thread</code>以从pluto获取缓冲区并将其放入 <code>rx_sample_queue</code>中。提交你设计的程序。(10%)</li>
<li>从 <code>rx_sample_queue</code>获取缓冲区。检测缓冲区中的前导码并解调接收的样本。将解调的数据包放入 <code>rx_packet_queue</code>，然后完成OfdmRx类的 <code>process()</code>。提交你设计的程序。(20%)</li>
<li>问题1：描述单向OFDM接收机的过程。解释控制台输出，并描述它们的作用。<code>socket</code>接收机和 <code>pluto</code>接收机之间的区别是什么？(5%)</li>
<li>问题2：解释为什么我们在发射机中只有“<code>tx_queue</code>，但在接收机中有 <code>rx_sample_queue</code>和 <code>rx_packet_queue</code>？(5%)</li>
<li>问题3：如果 <code>rx_sample_queue</code>或 <code>rx_packet_queue</code>没有及时处理，会发生什么？(5%)</li>
</ul>
<a class="header" href="print.html#提示-1" id="提示-1"><h5>提示</h5></a>
<ul>
<li>要使用pluto接收样本，可以调用 <code>samples=sdr_tx.rx()</code>。</li>
<li><code>rx_sample_queue_watcher_thread</code> 的设计类似于 <code>rx_packet_queue_watcher_thread</code>。</li>
<li>你可以更改在test_nodeB.py 中 <code>rx_buffer_size</code>的值，以帮助调试 <code>process()</code>。</li>
<li>你可以使用 <code>time</code>库来测量 <code>process()</code>中每个部分的时间消耗，并优化较慢的部分以提高处理速度。</li>
</ul>
<a class="header" href="print.html#第三部分-使用socket-phy收发机测试双向通信5" id="第三部分-使用socket-phy收发机测试双向通信5"><h3>第三部分: 使用Socket PHY收发机测试双向通信（5%）</h3></a>
<p>在这一部分中，节点A和B都具有收发机。在我们提供的参考代码中，节点A触发包传输，并且在节点B接收到包后，它将回馈一个随机的包。然后节点A对随机包进行解码。整个过程继续。</p>
<a class="header" href="print.html#设置和要求-2" id="设置和要求-2"><h4>设置和要求</h4></a>
<ul>
<li>运行下面的代码，并记录控制台输出。(5%)</li>
</ul>
<pre><code class="language-bash">(py37)$ python test_nodeB.py -p socket -l double    # run first
(py37)$ python test_nodeA.py -p socket -l double
</code></pre>
<a class="header" href="print.html#第四部分使用ofdm-phy收发机设计双向通信10" id="第四部分使用ofdm-phy收发机设计双向通信10"><h3>第四部分：使用OFDM PHY收发机设计双向通信（10%）</h3></a>
<p>现在我们将设计OFDM PHY收发机。事实上，如果你完成以上部分，我们提供的参考代码确实是一个收发机。你只需要运行源代码，了解它们的工作原理。</p>
<a class="header" href="print.html#设置和要求-3" id="设置和要求-3"><h4>设置和要求</h4></a>
<ul>
<li>提交你设计的程序。运行下面的代码，并记录控制台输出。(5%)</li>
</ul>
<pre><code class="language-bash">(py37)$ python test_nodeB.py -p pluto -l double        # run first
(py37)$ python test_nodeA.py -p pluto -l double
</code></pre>
<ul>
<li>问题1：描述双向通信的过程。解释控制台输出，并描述它们的作用。Socket PHY和Pluto（OFDM）PHY之间的区别是什么？(5%)</li>
</ul>
<a class="header" href="print.html#提示-2" id="提示-2"><h4>提示</h4></a>
<ul>
<li>注意，我们在以下两个flow应该使用不同频率：flow: A --&gt; B和folw: B --&gt; A，以避免交叉流干扰。在我们提供的代码中，频率设置为不同的值。你应该根据你的组号改变频率。</li>
<li>如果你的电脑无法同时带动两台设备，请尝试在不同的电脑上运行节点A和B。</li>
</ul>
<a class="header" href="print.html#project-大作业" id="project-大作业"><h1>Project 大作业</h1></a>
<a class="header" href="print.html#报告提交" id="报告提交"><h3>报告提交</h3></a>
<ul>
<li>截止日期: <strong>23:59, 29 May, 2022.</strong></li>
<li>提交邮箱: hongzhuyu@stu.xmu.edu.cn</li>
<li><strong>每组提交一份报告</strong></li>
<li><strong>逾期提交每天会扣除5%的分数，最高扣35%</strong></li>
<li><strong>将Project最终演示视频提交视频网站（比如youku, bilibili），并在你的报告中附上链接</strong></li>
</ul>
<a class="header" href="print.html#检查时间" id="检查时间"><h3>检查时间</h3></a>
<ul>
<li><strong>将于 <strong>14:30-22:00, 20 June 2022</strong> 在学武楼 G102 检查</strong></li>
<li>检查完毕归还Pluto设备</li>
</ul>
<a class="header" href="print.html#简介-4" id="简介-4"><h3>简介</h3></a>
<p>到目前为止，我们已经开发了OFDM PHY 在线收发器的双向通信。 在这次任务中，我们的开发 <strong>都是基于双向通信</strong>。我们将首先在节点A和节点B收发器上开发数据速率、丢包率和往返时间(RTT)计算。</p>
<p>然后，我们将开发支持可靠数据传输（RDT）的停止等待ARQ协议。 这样，节点B可以可靠地接收到节点A发送的所有数据包。最后，我们将利用OFDM PHY 技术开发可靠的图像传输，将之前的所有内容粘合在一起。也就是说，我们可以通过Pluto设备将图像从一台PC发送到另一台PC。</p>
<p>在本次任务中，你需要</p>
<ul>
<li>在链路层 (即, LLC层)重新设计帧结构以支持数据统计计算;</li>
<li>根据重新设计的帧结构设计停止等待ARQ协议;</li>
<li>用图像传输应用程序测试可靠数据传输RDT;</li>
</ul>
<p>为了帮助开发Project，我们提供</p>
<ul>
<li>用于socket的数据包丢失和延迟模拟器API <code>simu_pkt_loss_delay()</code>。我们使用socket来模拟 PHY 层以及帮助你开发ARQ协议;</li>
<li>图像信息提取APIs。 图像的基本信息通常包括宽度、高度和灰度。节点A可以将这些信息与第一个数据包一起发送给节点B，然后节点B可以准确地恢复整个图像。</li>
</ul>
<a class="header" href="print.html#第1部分用socket-phy的不可靠的数据传输--20" id="第1部分用socket-phy的不可靠的数据传输--20"><h3>第1部分:用Socket PHY的不可靠的数据传输  (20%)</h3></a>
<a class="header" href="print.html#11-设计-数据帧-和-ack-帧结构-5" id="11-设计-数据帧-和-ack-帧结构-5"><h4>1.1 设计 数据帧 和 ACK 帧结构 (5%)</h4></a>
<a class="header" href="print.html#步骤和要求" id="步骤和要求"><h5>步骤和要求</h5></a>
<ul>
<li>设计数据帧和ACK帧结构。 完成 llc_tx.py 和 llc_rx.py 中的 <code>pack</code> and <code>unpack</code> 函数。 提交你开发的程序。 (5%)</li>
</ul>
<a class="header" href="print.html#提示-3" id="提示-3"><h5>提示</h5></a>
<ul>
<li><code>pack</code> 和 <code>unpack</code> 函数可以根据实验3来完成。</li>
<li>你可以使用llc_utils.py 中的 <code>dec2bin</code> 和 <code>bin2dec</code>  以实现十进制数与二进制数组之间的转换。</li>
</ul>
<a class="header" href="print.html#12数据统计计算-15" id="12数据统计计算-15"><h4>1.2数据统计计算 (15%)</h4></a>
<a class="header" href="print.html#步骤和要求-1" id="步骤和要求-1"><h5>步骤和要求</h5></a>
<pre><code class="language-bash">(py37)$ python test_nodeB.py -p socket    # run first
(py37)$ python test_nodeA.py -p socket --arq-mode=null-ARQ -t 0.5
</code></pre>
<ul>
<li>计算 llc_rx.py 中的平均数据速率 (节点B)。运行上述代码，记录控制台输出，并提交你开发的程序。 (5%)</li>
<li>计算 llc_tx.py 和 llc_rx.py 中的丢包率(节点A&amp;B)。运行上述代码，记录控制台输出，并提交你开发的程序。 (5%)</li>
<li>计算 llc_tx.py 中的往返时间(RTT)和平均RTT(节点A)。运行上述代码，记录控制台输出，并提交你开发的程序。 (5%)</li>
</ul>
<a class="header" href="print.html#提示-4" id="提示-4"><h5>提示</h5></a>
<ul>
<li>你可以使用 <code>time.time()</code> 来记录数据包到达时间。</li>
<li>丢包率和RTT的计算高度依赖于序列号。</li>
</ul>
<a class="header" href="print.html#第2部分-用ofdm-phy的不可靠数据传输-20" id="第2部分-用ofdm-phy的不可靠数据传输-20"><h3>第2部分: 用OFDM PHY的不可靠数据传输 (20%)</h3></a>
<a class="header" href="print.html#步骤和要求-2" id="步骤和要求-2"><h5>步骤和要求</h5></a>
<pre><code class="language-bash">(py37)$ python test_nodeB.py -p pluto    # run first
(py37)$ python test_nodeA.py -p pluto --arq-mode=null-ARQ -t 0.5
</code></pre>
<ul>
<li>使用上述代码重复1.2部分，其中使用OFDM (Pluto)作为PHY。(20%)</li>
</ul>
<a class="header" href="print.html#提示-5" id="提示-5"><h5>提示</h5></a>
<ul>
<li>ofdm_tx.py 和 ofdm_rx.py 可以从你完成的实验3中拷贝过来。</li>
<li>test_nodeA.py中的 <code>-t</code> 选项可以相应修改。</li>
</ul>
<a class="header" href="print.html#第3部分-用socket-phy的停止等待arq协议-40" id="第3部分-用socket-phy的停止等待arq协议-40"><h3>第3部分: 用Socket PHY的停止等待ARQ协议 (40%)</h3></a>
<a class="header" href="print.html#步骤和要求-3" id="步骤和要求-3"><h5>步骤和要求</h5></a>
<pre><code class="language-bash">(py37)$ python test_nodeB.py -p socket    # run first
(py37)$ python test_nodeA.py -p socket --arq-mode=stop-and-wait-ARQ -t 0.5
</code></pre>
<ul>
<li>在llc_tx.py 中为节点A开发停止等待ARQ协议。运行上述代码，记录控制台输出。解释你的协议设计，并提交你开发的程序。(35%)</li>
<li>问题1: 将控制台输出与第1部分的不可靠数据传输相比较，并解释它们之间的差别。(5%)</li>
</ul>
<a class="header" href="print.html#提示-6" id="提示-6"><h5>提示</h5></a>
<ul>
<li>下一个要传输的数据帧依赖于在节点A收到的ACK帧。</li>
</ul>
<a class="header" href="print.html#第4部分-可靠图像传输-20" id="第4部分-可靠图像传输-20"><h3>第4部分: 可靠图像传输 (20%)</h3></a>
<a class="header" href="print.html#步骤和要求-4" id="步骤和要求-4"><h5>步骤和要求</h5></a>
<ul>
<li>在 llc_tx.py 中开发新的 <code>send()</code> 函数 以使用停止等待ARQ协议来传输从图像中提取的数据包。记录控制台输出以及你使用的图像。提交你开发的程序。(10%)</li>
<li>在 llc_rx.py 中开发新的 <code>recv()</code> 函数 来接收图像的数据包。记录控制台输出，并保存图像。提交你开发的程序。 (10%)</li>
</ul>
<a class="header" href="print.html#提示-7" id="提示-7"><h5>提示</h5></a>
<ul>
<li>test_read_save_img.py中提供了读取和保存图像的APIs。</li>
<li>你可以使用你自己的图像来测试你的程序。</li>
</ul>
<a class="header" href="print.html#加分题-30" id="加分题-30"><h3>加分题 (+30%)</h3></a>
<a class="header" href="print.html#加分1-滑动窗口-arq-20" id="加分1-滑动窗口-arq-20"><h4>加分1: 滑动窗口 ARQ (+20%)</h4></a>
<a class="header" href="print.html#步骤和要求-5" id="步骤和要求-5"><h5>步骤和要求</h5></a>
<ul>
<li>使用滑动窗口ARQ重复第3部分。 (+20%)</li>
</ul>
<a class="header" href="print.html#加分2-用gui-demo实现循环图像传输与显示-10" id="加分2-用gui-demo实现循环图像传输与显示-10"><h4>加分2: 用GUI Demo实现循环图像传输与显示 (+10%)</h4></a>
<a class="header" href="print.html#步骤和要求-6" id="步骤和要求-6"><h5>步骤和要求</h5></a>
<ul>
<li>重复第4部分以支持多个图像传输。(+5%)</li>
<li>用 GUI Demo 显示图像。 (+5%)</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
